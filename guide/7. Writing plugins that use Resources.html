<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>7. Writing plugins that use Resources</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="7. Writing plugins that use Resources">7. Writing plugins that use Resources</a></h1>There are generally two kinds of plugins that provide Resources artefacts; those that expose resources such as JavaScript libraries, and those that supply custom mappers e.g. to minify resources.<p class="paragraph"/><h2>Plugin dependencies</h2><p class="paragraph"/>If your plugin exposes resources, it does not need to depend on the "resources" plugin. In fact if it is intended to interoperate with applications that do <strong class="bold">not</strong> use the Resources framework, you should not depend on the "resources" plugin. Defining XXXXResources.groovy files does not require dependency on the plugin at all.<p class="paragraph"/>If you are exposing a mapper, you will need to have a dependency on the "resources" plugin so that you can reference the MapperPhase enum.<p class="paragraph"/><h2>Versioning</h2><p class="paragraph"/>When exposing resources, it is becoming a convention to ensure that your plugin has a version number that matches the version of the libraries you are exposing - with point releases or other suffixes to denote interim plugin releases where the library is the same but the plugin has changed.<p class="paragraph"/>This is important because it allows other applications that use the library you expose to specify which version of it they require, without having to mentally map the library version to yet another plugin version.<p class="paragraph"/><h2>Avoiding bloat</h2><p class="paragraph"/>It's important to remember that the dependencies introduced by a mapper plugin end up in the user's WAR deployment. Therefore mapper plugins should have minimal dependencies, and where possible focus on a specific niche of mapping - for example avoid creating something like a monolithic "minified-resources" plugin that bundles every known minifier library together.<p class="paragraph"/><h2>Naming conventions for mapper plugins</h2><p class="paragraph"/>It is recommended that developers establish sound naming conventions in the community such that it is easy for users to tell what a mapper plugin will do for them, in a way consistent with other mapper plugins of similar type.<p class="paragraph"/>For example there may be YUI and a Google CSS minifier plugins. These should be clearly named e.g:<p class="paragraph"/>yui-css-minified-resources
google-css-minified-resources<p class="paragraph"/>In addition the mappers must be clearly named, i.e. YuiCssMinifyMapper and GoogleCssMinifyMapper. Such that the user can exclude them selectively with code such as <strong class="bold">exclude:'yuicssminify'</strong>.<p class="paragraph"/>
    </body>
</html>
