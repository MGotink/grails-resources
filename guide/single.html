<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Resources Plugin 1.0 - Reference Documentation</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Style" charset="utf-8"/>
        <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8" />
    </head>
    <body class="body">
        <div id="header">
            <div class="images"><br/><br/>
                <a href="http://grails.org" target="_blank"><img alt="The Grails Framework" src="../img/grails.png" border="0"/></a>
                <span style="right:30px; top:20px; position:absolute;">
                    <a href="../index.html" target="_top">Frames</a> | <a href="index.html" target="_top">No Frames</a><br/><br/>
                    <a href="http://springsource.com" target="_blank"><img alt="SpringSource - A Division of VMware" src="../img/springsource-logo.png" border="0"/></a>
                </span>
            </div>
            <div class="message">resources</div>
            <h1>Resources Plugin - Reference Documentation</h1>
            <p><strong>Authors:</strong> Marc Palmer (marc@grailsrocks.com)</p>
            <p><strong>Version:</strong> 1.0</p>
            <em></em>
        </div>

        <div id="toc">
            <h2>Table of Contents</h2>
            <div class="tocItem" style="margin-left:0px"><a href="#1. Overview">1. Overview</a></div><div class="tocItem" style="margin-left:0px"><a href="#2. Concepts">2. Concepts</a></div><div class="tocItem" style="margin-left:0px"><a href="#3. Declaring resources">3. Declaring resources</a></div><div class="tocItem" style="margin-left:0px"><a href="#4. Using resources">4. Using resources</a></div><div class="tocItem" style="margin-left:0px"><a href="#5. Overriding resources">5. Overriding resources</a></div><div class="tocItem" style="margin-left:0px"><a href="#6. Creating custom mappers">6. Creating custom mappers</a></div><div class="tocItem" style="margin-left:0px"><a href="#7. Writing plugins that use Resources">7. Writing plugins that use Resources</a></div><div class="tocItem" style="margin-left:0px"><a href="#8. Debugging">8. Debugging</a></div><div class="tocItem" style="margin-left:0px"><a href="#9. Configuration">9. Configuration</a></div>
        </div>
        <div id="content">
            <h1><a name="1. Overview">1. Overview</a></h1>
This plugin provides the Resources framework for Grails.<p class="paragraph"/>The issues that the Resources framework tackles are:
<ul class="star">
<li>Web application performance tuning is difficult</li>
<li>Correct ordering of resources, and deferred inclusion of JavaScript</li>
<li>Resources that depend on others that must be loaded first</li>
<li>The need for a standard way to expose static resources in plugins and applications</li>
<li>The need for an extensible processing chain to optimize resources</li>
<li>Preventing inclusion of the same resource multiple times</li>
</ul><p class="paragraph"/>The Resources plugin achieves this end by introducing new artefacts and processing the resources using the server's local file system.<p class="paragraph"/>It adds artefacts for declaring resources, for declaring "mappers" that can process resources, and a servlet filter to serve processed resources.<p class="paragraph"/>In tandem with Sitemesh layouts and the Grails plugin dependency system, you gain the ability to express dependencies on specific UI libraries, and the ability to specify the resources that a page needs anywhere in the page GSPs or even in rendered GSP templates.<p class="paragraph"/>The Resource framework tags confer a whole new level of abstraction and power to application and plugin developers. It makes possible new patterns for managing resources and smart handling of JavaScript and CSS code.<p class="paragraph"/><h2>Quick Start</h2><p class="paragraph"/>To demonstrate the power of the framework, here's a quick demonstration of usage with the jQuery, jQuery-Ui and Blueprint plugins which exposes resource modules.<p class="paragraph"/><h3>Make sure jQuery plugin is installed</h3><p class="paragraph"/>For Grails 1.4, it is installed by default. For older versions: <strong class="bold">grails install-plugin jquery</strong><p class="paragraph"/><h3>Install jQuery UI and Blueprint plugins</h3><p class="paragraph"/>Just run:
<div class="code"><pre>grails install&#45;plugin jquery&#45;ui
grails install&#45;plugin blueprint</pre></div><p class="paragraph"/><h3>Edit your Sitemesh layout</h3><p class="paragraph"/>You need to add &#60;r:layoutResources/&#62; twice to your page, for the &#60;head&#62; resources and end-of-body resources.<p class="paragraph"/>Your grails-app/views/layouts/main.gsp:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;html&#62;</span>
   <span class="xml&#45;tag">&#60;head&#62;</span>
      <span class="xml&#45;tag">&#60;g:layoutTitle/&#62;</span>
      <span class="xml&#45;tag">&#60;r:layoutResources/&#62;</span>
   <span class="xml&#45;tag">&#60;/head&#62;</span>
   <span class="xml&#45;tag">&#60;body&#62;</span>
      <span class="xml&#45;tag">&#60;g:layoutBody/&#62;</span>
      <span class="xml&#45;tag">&#60;r:layoutResources/&#62;</span>
   <span class="xml&#45;tag">&#60;/body&#62;</span>
<span class="xml&#45;tag">&#60;/html&#62;</span></pre></div><p class="paragraph"/><h3>Edit your GSP page to include jQuery</h3><p class="paragraph"/>All you have to do here is add &#60;r:require&#62; to your GSP page. Anywhere will do, but in &#60;head&#62; makes sense, and add a bit of code:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;html&#62;</span>
   <span class="xml&#45;tag">&#60;head&#62;</span>
      <span class="xml&#45;tag">&#60;meta name=<span class="xml&#45;quote">"layout"</span> content=<span class="xml&#45;quote">"main"</span>/&#62;</span>
      <span class="xml&#45;tag">&#60;r:require modules=<span class="xml&#45;quote">"jquery&#45;ui, blueprint"</span>/&#62;</span><p class="paragraph"/>      <span class="xml&#45;tag">&#60;r:script&#62;</span>
          $(function() &#123;
              $('&#35;form').dialog('open');
          &#125;);
      <span class="xml&#45;tag">&#60;/r:script&#62;</span>
   <span class="xml&#45;tag">&#60;/head&#62;</span>
   <span class="xml&#45;tag">&#60;body&#62;</span>
      <span class="xml&#45;tag">&#60;div id=<span class="xml&#45;quote">"form"</span>&#62;</span>
           Hello World
      <span class="xml&#45;tag">&#60;/div&#62;</span>  
   <span class="xml&#45;tag">&#60;/body&#62;</span>
<span class="xml&#45;tag">&#60;/html&#62;</span></pre></div><p class="paragraph"/><h3>View the page source</h3><p class="paragraph"/>When you run this and request the GSP page, you should view the source and look at what is happening in the page. Use Safari or Chrome resource inspector to see what files were requested and when.<p class="paragraph"/>You should have a page that is rendered with the Blueprint CSS framework, pulling in both jQuery and jQuery-UI, with jQuery-UI JS deferred to the end of the page, jQuery loaded in the head, and the "docuemnt ready" JS code fragment to set up the page is rendered right at the end of the body after jQuery UI has loaded.<p class="paragraph"/>All with almost zero effort!<p class="paragraph"/><h3>Now optimize your application</h3><p class="paragraph"/>Installing the "cached-resources" and "zipped-resources" plugins and running your app again, you will then find that your resources are cached in the browser "eternally" and transferred with zip encoding.<p class="paragraph"/>No other code changes are necessary.
<h1><a name="2. Concepts">2. Concepts</a></h1>There are several concepts introduced in the Resources framework which which you may not be familiar.<p class="paragraph"/>It may help yout to understand the rest of the documentation if you familiarize yourself with these first.<p class="paragraph"/><h2>Resources</h2><p class="paragraph"/>By resources we mean typically static resources that are used to render your application views, or other files served to your users.<p class="paragraph"/>This includes CSS, JavaScript and usually some icons and images.<p class="paragraph"/><h2>Modules</h2><p class="paragraph"/>In the resources framework, you define resource modules that have a name and contain one or more resources. You use tags to indicate which modules your pages need.<p class="paragraph"/><h2>Module dependencies</h2><p class="paragraph"/>Specifying module dependencies means that you don't have to worry about the order of resource inclusion in your pages. By telling the framework which modules require other modules, you allow it to decide the correct order.<p class="paragraph"/>Just like Grails transitive dependencies, this will pull in all the modules required if you require one module that has other dependencies.<p class="paragraph"/><h2>Mappers</h2><p class="paragraph"/>Resource mappers are Grails artefacts that participate in the processing of resources. You start with a copy of the original resource, and after applying all the necessary mappers, you have the - typically mutated - final file to serve to users.<p class="paragraph"/>Mappers can modify and/or move and rename the file.<p class="paragraph"/><h2>Mapper phases</h2><p class="paragraph"/>Resource mappers are applied in a specific order, denoted by a series of well-defined phases. This ensures that the right processing happens at the right times.<p class="paragraph"/><h2>Undeclared Resources</h2><p class="paragraph"/>Undeclared resources are those that you link to using the Resources framework tags (or Grails 1.4 and higher g:resource/g:img and other linking tags that are resources-aware) but you did not explicitly declare in any modules.<p class="paragraph"/><h2>Ad-hoc/Legacy Resources</h2><p class="paragraph"/>Ad-hoc resources are tags that do not use the Resources mechanisms to create their links. Prior to Grails 1.4 this means links created with g:xxx tags instead of the r:xxx tags and hardcoded links to resources. For Grails 1.4 and higher these can only occur for hardcoded links to resources.<p class="paragraph"/><h2>Bundling</h2><p class="paragraph"/>Bundling is the act of aggregating two or more resources of the same type into one file. This reduces the number of requests the browser must make to your site, thus speeding up the page load time.<p class="paragraph"/><h2>CSS Rewriting</h2><p class="paragraph"/>Rewriting CSS is the act of changing any URLs in your CSS files so that they continue to point to the correct resource even if the CSS is bundled into a new file and/or moved to a new location in the filesystem.<p class="paragraph"/><h2>Disposition</h2><p class="paragraph"/>The disposition of a resource indicates where in the response you would like the link to appear. By default the "head" disposition causes links to be rendered in the &#60;head&#62; section, and "defer" disposition causes links to JavaScript to be rendered at the end of the body.
<h1><a name="3. Declaring resources">3. Declaring resources</a></h1>You can declare your resources in your Application's Config.groovy or in a Resources artefact in your application or plugins.<p class="paragraph"/>This is done using a simple DSL in for both cases. You define the names of the modules you have and the resources within them, and dependencies between modules.<p class="paragraph"/><h2>The resource DSL</h2><p class="paragraph"/>There are few methods to call in the DSL. At the top level method calls taking a single Closure argument are translated into module names. The code in the nested closure represents the module definition.<p class="paragraph"/>A module definition can call dependsOn, defaultBundle and resource methods:<p class="paragraph"/><div class="code"><pre>modules = &#123;
    core &#123;
        dependsOn 'jquery, utils'
        defaultBundle 'ui'<p class="paragraph"/>        resource url:'/js/core.js', disposition: 'head'
        resource url:'/js/ui.js'
        resource url:'/css/main.css', 
        resource url:'/css/branding.css'
        resource url:'/css/print.css', attrs:&#91;media:'print'&#93;
    &#125;<p class="paragraph"/>    utils &#123;
        dependsOn 'jquery'<p class="paragraph"/>        resource url:'/js/utils.js' 
    &#125;<p class="paragraph"/>    forms &#123;
        dependsOn 'core,utils'
        defaultBundle 'ui'<p class="paragraph"/>        resource url:'/css/forms.css'
        resource url:'/js/forms.js'
    &#125;
&#125;</pre></div><p class="paragraph"/>The above DSL defines three resource modules; 'core', 'utils' and 'forms'. The resources in these modules will be automatically bundled out of the box according to the module name, resulting in fewer files. You can override this with "bundle:'someOtherName'" on each resource, or call defaultBundle on the module<p class="paragraph"/><h3>The dependsOn method</h3><p class="paragraph"/>To declare that a module depends on another, you use dependsOn. It accepts a string or list of names. The string can be comma-delimited to specify multiple dependencies. You can also call dependsOn as many times as you like:<p class="paragraph"/><div class="code"><pre>modules = &#123;
    core &#123;
        dependsOn 'jquery, utils'
        dependsOn 'other'
        dependsOn(&#91;'heavy', 'metal'&#93;)
    &#125;
&#125;</pre></div><p class="paragraph"/><h3>The resource method</h3><p class="paragraph"/>Declaring a resource requires the "resource" method. This takes a map of arguments that define the URL of the resource and any other specific options you require.<p class="paragraph"/>The map arguments are:
<ul class="star">
<li>url - Required. The app-relative URL of the resource as a String, or a g:resource-style map of dir, file and plugin attributes.</li>
<li>exclude - Optional. A comma-delimited String or a List of names of mappers/operations to exclude. The special "*" value excludes all mappers and operations - the resource will be passed-through as is. You can exclude specific operations such as "minify" if the resource has already been minified.</li>
<li>bundle - Optional. The name of the bundle to put the resource into. See "Bundling" for more details</li>
<li>disposition - Optional. The disposition of the resource. If not specified, it will default to a value appropriate for the type of the resource. For JavaScript this default is "defer". To force code into the &#60;head&#62;, set it to "head".</li>
<li>attrs - Optional. Map of attribute names and values to pass through to the linking tag when the resource is rendered. e.g. use to pass attrs:media:'print' for print-only CSS, or "type". Note that supplying "attrs" will prevent bundling of the resource. Passing in "type" (which is passed through to <a href="../ref/Tags/external.html" class="Tags">external</a> tag) allows you to tell the framework that the resource is a specific type irrespective of the file extension. For example if you have a file that ends ".less" but you want the framework to treat it like CSS when rendering links, you need to set attrstype:"css".</li>
<li>id - Optional. Module-unique id of the resource to be used when overriding resource properties</li>
<li>linkOverride - Optional. The URL to use when rendering links for the resource, instead of the processed URL. Allows your external resources to participate in dependency management.</li>
<li>wrapper - Optional. A Closure that will be used to render the resource link. The correct markup for linking will be passed in. Used primarily for MSIE workarounds i.e: wrapper: &#123; s -&#62; "&#60;!--if lt IE 8&#62;$s&#60;!endif--&#62;" &#125;. Note that supplying a wrapper will prevent bundling of that resource.</li>
</ul><p class="paragraph"/>Examples:<p class="paragraph"/><div class="code"><pre>modules = &#123;
    core &#123;
        resource url:&#91;dir:'css/blueprint',file:'screen.css'&#93;, attrs:&#91;media:'screen, projection'&#93;, bundle:'core&#45;ui'
        resource url:&#91;dir:'css/blueprint',file:'ie.css'&#93;, attrs:&#91;media:'screen, projection'&#93;,  
            wrapper: &#123; s &#45;&#62; <span class="java&#45;quote">"&#60;!&#45;&#45;&#91;<span class="java&#45;keyword">if</span> lt IE 8&#93;&#62;$s&#60;!&#91;endif&#93;&#45;&#45;&#62;"</span> &#125;<p class="paragraph"/>        resource id:'main&#45;js', url:'js/coreutils&#45;min.js', disposition: 'head', exclude:'minify'<p class="paragraph"/>        resource url:'js/lib.js', linkOverride:'http://mycdn.com/js/lib.js'
    &#125;<p class="paragraph"/>    ui &#123;
        resource url:'/css/forms.css', bundle:'core&#45;ui'
        resource url:'/js/forms.js'
    &#125;
&#125;</pre></div><p class="paragraph"/><h3>The defaultBundle method</h3><p class="paragraph"/>By default, modules with more than one resource will be auto-bundled using the module name as a bundle name. You can override this by setting the default bundle name for the module by calling defaultBundle. This name can be the same as bundles used in other modules, to bundle resoures across module boundaries.<p class="paragraph"/>The method takes a String or boolean as parameter. A string sets the default bundle name, and passing in a boolean false will turn off all default bundling for that module.<p class="paragraph"/><div class="code"><pre>modules = &#123;
    core &#123;
        defaultBundle 'core&#45;ui'<p class="paragraph"/>        resource url:&#91;dir:'css/blueprint',file:'screen.css'&#93;, attrs:&#91;media:'screen, projection'&#93;
        resource url:&#91;dir:'css/blueprint',file:'ie.css'&#93;, attrs:&#91;media:'screen, projection'&#93;,  
            wrapper: &#123; s &#45;&#62; <span class="java&#45;quote">"&#60;!&#45;&#45;&#91;<span class="java&#45;keyword">if</span> lt IE 8&#93;&#62;$s&#60;!&#91;endif&#93;&#45;&#45;&#62;"</span> &#125;<p class="paragraph"/>        resource id:'main&#45;js', url:'js/coreutils&#45;min.js', disposition: 'head', exclude:'minify'<p class="paragraph"/>        resource url:'js/lib.js', linkOverride:'http://mycdn.com/js/lib.js'
    &#125;<p class="paragraph"/>    ui &#123;
        defaultBundle 'core&#45;ui'<p class="paragraph"/>        resource url:'/css/forms.css', bundle:'theme'
        resource url:'/js/forms.js'
    &#125;
&#125;</pre></div><p class="paragraph"/>Here you can see that the fallback bundle for both modules is set to "core-ui" and individual resources can still override this.<p class="paragraph"/><h2>Resource artefacts</h2><p class="paragraph"/>The best place to put these declarations is in a resource artefact. These have a filename ending in Resources.groovy and live in grails-app/conf.<p class="paragraph"/>Note that these are Groovy ConfigSlurper scripts that are therefore environment-aware, so you can declare different resources for e.g. dev, test and production.<p class="paragraph"/>Example grails-app/conf/MyAppResources.groovy:<p class="paragraph"/><div class="code"><pre>modules = &#123;
    core &#123;
        dependsOn 'jquery, utils'
        defaultBundle 'ui'<p class="paragraph"/>        resource url:'/js/core.js', disposition: 'head'
        resource url:'/js/ui.js'
    &#125;<p class="paragraph"/>    utils &#123;
        dependsOn 'jquery'<p class="paragraph"/>        resource url:'/js/utils.js' 
    &#125;<p class="paragraph"/>    forms &#123;
        dependsOn 'core,utils'
        defaultBundle 'ui'<p class="paragraph"/>        resource url:'/css/forms.css'
        resource url:'/js/forms.js'
    &#125;
&#125;</pre></div><p class="paragraph"/><h2>Config.groovy</h2><p class="paragraph"/>Applications can also define resources in Config.groovy if they wish. Simply assign the DSL to the <strong class="bold">grails.resources.modules</strong> property.<p class="paragraph"/>Example in grails-app/conf/Config.groovy:<p class="paragraph"/><div class="code"><pre>grails.resources.modules = &#123;
    core &#123;
        dependsOn 'jquery, utils'
        defaultBundle 'ui'<p class="paragraph"/>        resource url:'/js/core.js', disposition: 'head'
        resource url:'/js/ui.js'
    &#125;<p class="paragraph"/>    utils &#123;
        dependsOn 'jquery'<p class="paragraph"/>        resource url:'/js/utils.js' 
    &#125;<p class="paragraph"/>    forms &#123;
        dependsOn 'core,utils'
        defaultBundle 'ui'<p class="paragraph"/>        resource url:'/css/forms.css'
        resource url:'/js/forms.js'
    &#125;
&#125;</pre></div><p class="paragraph"/><h2>Bundling</h2><p class="paragraph"/>As mentioned earlier, bundling can be controlled in a number of ways. The logic runs as follows:
<ol>
<li>If a resource has an explicit bundle property set, this is used.</li>
<li>If there is no explicit bundle property set on the resource, it will use the default for the module</li>
<li>The default for the module is "bundle_" plus the name of the module unless defaultBundle has been called</li>
<li>If defaultBundle has been called in the module with a string, that name is used for the resource's bundle</li>
<li>If defaultBundle has been called in the module with a boolean false, no bundling will occur on the resource, only resources with a bundle specified will be bundled.</li>
</ol><p class="paragraph"/><strong class="bold">NOTE</strong> If a resource declares "attrs" or "wrapper" it will not be bundled at all. This is because bundling does not make sense in this situation unless all the attrs and wrapper logic match.<p class="paragraph"/><h1><a name="4. Using resources">4. Using resources</a></h1>Now that you know how to declare resources, you need to use them in your page.<p class="paragraph"/>There are several tags for this purpose, but the primary means is to use the &#60;r:require&#62; tag to indicate which modules you need, and the &#60;r:layoutResources/&#62; tag to perform the rendering of the resources.<p class="paragraph"/>The &#60;r:require&#62; tag causes the framework to look up all the resources required to satisfy your module dependencies. However nothing is rendered at that point.<p class="paragraph"/>The &#60;r:layoutResources/&#62; tag is called to render the resources themselves (and internally it calls into r:external for each resource). This tag has special behaviour, in that the first time you call it, it automatically renders only resources with disposition "head". The second time you call it, it automatically renders only resources with disposition "defer".<p class="paragraph"/><h2>Linking to CSS, JavaScript and Favicons</h2><p class="paragraph"/>So you need to add two calls to &#60;r:layoutResource/&#62; to your GSP page or sitemesh layout. Normally you will place it in your sitemesh layout:<p class="paragraph"/>Your grails-app/views/layouts/main.gsp:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;html&#62;</span>
   <span class="xml&#45;tag">&#60;head&#62;</span>
      <span class="xml&#45;tag">&#60;g:layoutTitle/&#62;</span>
      <span class="xml&#45;tag">&#60;r:layoutResources/&#62;</span>
   <span class="xml&#45;tag">&#60;/head&#62;</span>
   <span class="xml&#45;tag">&#60;body&#62;</span>
      <span class="xml&#45;tag">&#60;g:layoutBody/&#62;</span>
      <span class="xml&#45;tag">&#60;r:layoutResources/&#62;</span>
   <span class="xml&#45;tag">&#60;/body&#62;</span>
<span class="xml&#45;tag">&#60;/html&#62;</span></pre></div><p class="paragraph"/>You can of course include any common modules you require in your sitemesh layout using &#60;r:require&#62; but they must appear before the first &#60;r:layoutResources/&#62;.<p class="paragraph"/>In your GSP pages you invoke &#60;r:require&#62; as many times as required, even inside GSP templates that you include with g:render, and you can include resources conditionally - something that can be really hard to do without resource dependency management.<p class="paragraph"/>Example GSP page:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;html&#62;</span>
   <span class="xml&#45;tag">&#60;head&#62;</span>
      <span class="xml&#45;tag">&#60;meta name=<span class="xml&#45;quote">"layout"</span> content=<span class="xml&#45;quote">"main"</span>/&#62;</span>
      <span class="xml&#45;tag">&#60;r:require module=<span class="xml&#45;quote">"jquery&#45;ui, blueprint"</span>/&#62;</span>
      <span class="xml&#45;tag">&#60;g:if test=<span class="xml&#45;quote">"$&#123;customerBranding&#125;"</span>&#62;</span>
          <span class="xml&#45;tag">&#60;r:require module=<span class="xml&#45;quote">"theme_$&#123;customer.theme&#125;"</span>/&#62;</span>
      <span class="xml&#45;tag">&#60;/g:if&#62;</span>
   <span class="xml&#45;tag">&#60;/head&#62;</span>
   <span class="xml&#45;tag">&#60;body&#62;</span>
      <span class="xml&#45;tag">&#60;div&#62;</span>
           Hello World
      <span class="xml&#45;tag">&#60;/div&#62;</span>  
   <span class="xml&#45;tag">&#60;/body&#62;</span>
<span class="xml&#45;tag">&#60;/html&#62;</span></pre></div><p class="paragraph"/><h2>Linking to images</h2><p class="paragraph"/>When you need to render an &#60;img&#62; tag that you wish to be subject to the Resources processing chain (e.g. to make it eternally cacheable) you should use the &#60;r:img&#62; tag:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;r:img uri=<span class="xml&#45;quote">"images/logo.png"</span> width=<span class="xml&#45;quote">"100"</span> height=<span class="xml&#45;quote">"50"</span>/&#62;</span><p class="paragraph"/><span class="xml&#45;tag">&#60;r:img dir=<span class="xml&#45;quote">"images"</span> file=<span class="xml&#45;quote">"logo.png"</span> width=<span class="xml&#45;quote">"100"</span> height=<span class="xml&#45;quote">"50"</span>/&#62;</span></pre></div><p class="paragraph"/>Usually this will produce a link to an undeclared resource. However you can declare images in modules and specify extra attributes in "attrs" to supply e.g. the width and height:<p class="paragraph"/><div class="code"><pre>modules = &#123;
    images &#123;
        resource url:'images/logo.png', attrs:&#91;width:100, height:50, alt:'Our logo'&#93;, disposition:'inline'
        resource url:'images/icon/add.png', attrs:&#91;width:32, height:32, alt:'Add'&#93;, disposition:'inline'
    &#125;
&#125;</pre></div><p class="paragraph"/>The disposition "inline" is optional - as long as you don't have any other modules that "dependOn" the images module and link using r:resource or r:img, you won't need this.<p class="paragraph"/><h2>Linking to resources explicitly, bypassing modules</h2><p class="paragraph"/>Sometimes you may need to link to a specific resource, or produce a URL pointing to the specific resource without rendering links to all the modules it depends on - or outside of a context where you can call &#60;r:layoutResources/&#62;. You may even wish to link to an undeclared resource, but still want it to be subject to processing on the fly.<p class="paragraph"/>To link to CSS or other resources that are not declared in a module you use &#60;r:external&#62;:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;r:external uri=<span class="xml&#45;quote">"js/custom.js"</span>/&#62;</span>
<span class="xml&#45;tag">&#60;script type=<span class="xml&#45;quote">"text/javascript"</span>&#62;</span>
    var urlOfCSSToLoadInJSCode = '$&#123;r.external(uri:<span class="xml&#45;quote">"css/custom.css"</span>).encodeAsJavaScript()';
<span class="xml&#45;tag">&#60;/script&#62;</span>
<span class="xml&#45;tag">&#60;r:external uri=<span class="xml&#45;quote">"icons/favicon.ico"</span>/&#62;</span></pre></div><p class="paragraph"/>This would output the &#60;script&#62; and &#60;link&#62; tags required to include those resources, without rendering their dependencies first - whether the resource is declared in a module or not. The example shows how you might pass the URL of a resource to some JavaScript code for use later at runtime.<p class="paragraph"/><h2>Including pieces of JavaScript code generated at runtime</h2><p class="paragraph"/>Often in an application, especially those using custom Grails tags and rich UIs, you will need to render fragments of JavaScript code while the page is being rendered. It is not always possible to know what JS code there will be in the page until the render process is finished.<p class="paragraph"/>The &#60;r:script&#62; tag allows you to specify sections of JavaScript text during page rendering, but if using Sitemesh layouts, you will be able to have these fragments appear either in &#60;head&#62; or deferred to the end of the page, just like other JavaScript resources.<p class="paragraph"/>This integrates with the disposition mechanism, allowing you to throw your JavaScript into a specific location:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;r:script/&#62;</span>
    window.alert('This is the end of the page!');
<span class="xml&#45;tag">&#60;/r:script&#62;</span><p class="paragraph"/><span class="xml&#45;tag">&#60;r:script disposition='head'/&#62;</span>
    window.alert('This is the head of the page!');
<span class="xml&#45;tag">&#60;/r:script&#62;</span></pre></div><p class="paragraph"/>What happens is the &#60;r:script&#62; tag stashes your fragment in the request attributes until &#60;r:layoutResources/&#62; is called - when it is pulled out of the attributes and rendered according to the current disposition being rendered.<p class="paragraph"/>This is ideal for other custom Grails GSP taglibs to use to write out their JS code used to e.g. set up UI elements:<p class="paragraph"/><div class="code"><pre>class MyCustomTagLib &#123;
    def datePicker = &#123;
        out &#60;&#60; r.script(disposition:'head') &#123;
            out &#60;&#60; '$("&#35;'+attrs.id.encodeAsJavaScript()+').datePicker();'
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>The order of code is preserved, and all such fragments are rendered <strong class="bold">after</strong> all the modules required by the page (in that disposition) have been included.<h1><a name="5. Overriding resources">5. Overriding resources</a></h1>When plugins provide resource module declarations, they may not choose the same resource attributes that you would like to use - in particular plugins will often auto-bundle resources by module name, or have dependencies that you'd like to tweak.<p class="paragraph"/>This is easy to achieve with the Resources framework, as your application can override the defaultBundle, dependsOn and resources of any module using the "overrides" clause:<p class="paragraph"/><div class="code"><pre>modules = &#123;
    overrides &#123;
        jquery &#123;
            // We want jquery bundled in with our other code
            defaultBundle 'monolith'
        &#125;<p class="paragraph"/>        otherModuleToTweak &#123;
            dependsOn 'something&#45;<span class="java&#45;keyword">else</span>&#45;we&#45;added'<p class="paragraph"/>            resource id:'main&#45;css', bundle: 'my&#45;bundle'
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>All you do is re-define the module inside your "overrides" clause (yes this mean no module can be called "overrides"), and provide new values for defaultBundle, dependsOn and individual resource attributes.<p class="paragraph"/>To override the attributes of resources, the original resource needs to have an id declared on it, or you can use the URI of the original resource if you no id was provided.<p class="paragraph"/>Arguments passed to the resource call in "overrides" are merged into those for the original resource, before being processed. There fore you can change or clear any values previously declared.
<h1><a name="6. Creating custom mappers">6. Creating custom mappers</a></h1>The resource processing chain uses ResourceMapper artefacts to do the work.<p class="paragraph"/>You can create your own ResourceMapper artefacts inside your application or plugins to perform tasks such as;
<ul class="star">
<li>Moving and renaming resources</li>
<li>Changing the contents of resource files (compress, minify, compile etc)</li>
<li>Set HTTP response headers when requests are processed</li>
</ul><p class="paragraph"/>Resource mappers only get the chance to map (process) each resource once - the final resource is then stored on disk to serve future requests.<p class="paragraph"/>
<h2>Defining a mapper</h2><p class="paragraph"/>Defining a resource mapper is easy. You create a file with ResourceMapper.groovy as the file suffix, in the grails-app/conf/resourceMappers folder.<p class="paragraph"/>The name of the mapper is extracted from the filename like any other Grails artefact, for example "TestResourceMapper" yields a mapper with name "test".<p class="paragraph"/>Example grails-app/conf/resourceMappers/TestResourceMapper.groovy:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.grails.plugin.resource.mapper.MapperPhase<p class="paragraph"/>class TestResourceMapper &#123;<p class="paragraph"/>    def phase = MapperPhase.MUTATION<p class="paragraph"/>    def map(resource, config) &#123;
        def file = <span class="java&#45;keyword">new</span> File(resource.processedFile.parentFile, <span class="java&#45;quote">"_$&#123;resource.processedFile.name&#125;"</span>)
        assert resource.processedFile.renameTo(file)
        resource.processedFile = file
        resource.updateActualUrlFromProcessedFile()
    &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>The only method a mapper must implement is <strong class="bold">map(resource, config)</strong> which is passed the <a href="http://github.com/grails-plugins/grails-resources/blob/master/src/groovy/org/grails/plugin/resource/ResourceMeta.groovy" target="blank">ResourceMeta</a> object that represents the resource and the mapper-specific config variables pulled out of grails.resources.&#60;mappername&#62;.<p class="paragraph"/>This method can do whatever it needs to the resource's file, provided it calls the updateActualUrlFromProcessedFile() method if the resource moves, unless you patch ResourceMeta.actualUrl manually.<p class="paragraph"/>You can change other properties of the resource, such as change the content type of the resource, add or modify tagAttributes (which are passed through when rendering the link for the resource).<p class="paragraph"/>That's all you need to do to create a mapper. The best way to learn how they work is to study the source of <a href="http://grails.org/plugin/cached-resources" target="blank">Cached-Resources</a> and <a href="http://grails.org/plugin/zipped-resources" target="blank">Zipped-Resources</a> plugins.<p class="paragraph"/><h2>Mapper phases and priority</h2><p class="paragraph"/>The example mapper shows the "phase" property being set to MapperPhase.MUTATION. The <a href="http://github.com/grails-plugins/grails-resources/blob/master/src/groovy/org/grails/plugin/resource/mapper/MapperPhase.groovy" target="blank">MapperPhase</a> enumeration provides the possible mapping phases in the order in which they occur during processing of resources:<p class="paragraph"/><div class="code"><pre>enum MapperPhase &#123;
    GENERATION, // create <span class="java&#45;keyword">new</span> assets = compile less files
    MUTATION, // alter/improve assets (may mean creating <span class="java&#45;keyword">new</span>/deleting aggregated resources) = spriting
    COMPRESSION, // reducing the file size but maintaining semantics = minify
    LINKNORMALISATION, // convert all inter asset references into a normal form = css links
    AGGREGATION, // combining mutiple assets into one = bundling
    RENAMING, // moving of physical assets = hashing
    LINKREALISATION, // convert normalised inter asset references into real form = css links
    ALTERNATEREPRESENTATION, // attach different representations of the asset = gzipping
    DISTRIBUTION, // moving assets to their hosting environment = s3, cdn
    ABSOLUTISATION, // update inter asset references to their distributed equivalent = css links
    NOTIFICATION // let the world know about the <span class="java&#45;keyword">new</span> resources = cache invalidation
&#125;</pre></div><p class="paragraph"/>In most cases it will be enough to specify your phase and operation (see next section). However in some cases there may be issues where multiple mappers in the same phase must operate in a specific order. In those cases a "priority" property can be set to specify the priority integer.<p class="paragraph"/>Mappers will be executed in phase order, in order of ascending priority within each phase. The default priority if not specified is equivalent to zero.<p class="paragraph"/><h2>Mapper operation</h2><p class="paragraph"/>The optional "operation" property allows you to specify the name of the kind of work performed by the mapper. Users can then prevent any mappers of this operation from executing on their resources.<p class="paragraph"/>The common example is to specify <strong class="bold">exclude:"minify"</strong> in a resource declaration to prevent any kind of minifying mapper from being applied to a resource that is already minified.<p class="paragraph"/>A similar operation called e.g. "compress" could be used to prevent duplicate zipping of resources that may have been pre-compressed (such as images).<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.grails.plugin.resource.mapper.MapperPhase<p class="paragraph"/>class TestResourceMapper &#123;<p class="paragraph"/>    def phase = MapperPhase.COMPRESS<p class="paragraph"/>    def operation = <span class="java&#45;quote">"compression"</span><p class="paragraph"/>    def map(resource, config) &#123;
        // Zip the file here
    &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>Note the operations and mapper names occupy the same namespace so that the "exclude" argument on resource declarations can apply to either.<p class="paragraph"/>Resources will fail fast at runtime if an operation is specified on any mapper, where there is also a mapper with a name the same as the operation.<p class="paragraph"/><h2>Processing only the right types of files</h2><p class="paragraph"/>Often a mapper is only meant to target certain file types or file patterns. Make it easier for your users by operating correctly out of the box, but specifying defaultExcludes and/or defaultIncludes for your mapper, which will filter the resources passed to your mapper:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.grails.plugin.resource.mapper.MapperPhase<p class="paragraph"/>class TestResourceMapper &#123;<p class="paragraph"/>    def phase = MapperPhase.MUTATION<p class="paragraph"/>    <span class="java&#45;keyword">static</span> defaultExcludes = &#91;
        '/&#42;&#42;/&#42;.png',
        '/&#42;&#42;/&#42;.gif',
        '/&#42;&#42;/&#42;.jpg',
        '/&#42;&#42;/&#42;.jpeg',
        '/&#42;&#42;/&#42;.gz',
        '/&#42;&#42;/&#42;.zip'
    &#93;
    <span class="java&#45;keyword">static</span> defaultIncludes = &#91; '/images/&#42;&#42;' &#93;<p class="paragraph"/>    def map(resource, config) &#123;
        &#8230;
    &#125;</pre></div><p class="paragraph"/>The use defaults can be overidden by the user with the <strong class="bold">grails.resources.&#60;mappername&#62;.includes</strong> and <strong class="bold">grails.resources.&#60;mappername&#62;.excludes</strong> Config variables.<p class="paragraph"/><h2>Adding request headers / intercepting requests</h2><p class="paragraph"/>Resource mappers also have the opportunity to take part in response handling so that they can adjust the response headers if necessary. You may need to adapt the handling of the current request to the request headers supplied.<p class="paragraph"/>Note that this cannot be used to change how the resource is mapped - the mapping is performed once only, but the response headers can be customized  every time the file is requested.<p class="paragraph"/>As an example, the Zipped-Resources plugin uses this mechanism to set the Content-Encoding header:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.grails.plugin.resource.mapper.MapperPhase<p class="paragraph"/>class ZipResourceMapper &#123;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> phase = MapperPhase.ALTERNATEREPRESENTATION<p class="paragraph"/>    /&#42;&#42;
     &#42; Rename the file to a hash of it's contents, and set caching headers 
     &#42;/
    def map(resource, config) &#123;
        // Do the zipping
        ...<p class="paragraph"/>        // Set up response headers
        resource.requestProcessors &#60;&#60; &#123; req, resp &#45;&#62;
            resp.setHeader('Content&#45;Encoding', 'gzip')
        &#125;    
    &#125;
&#125;</pre></div><p class="paragraph"/>Here the mapper adds a Closure that takes the request and response objects to the resource's requestProcessors list. These will be called in the order they are defined on the resource.<p class="paragraph"/><h1><a name="7. Writing plugins that use Resources">7. Writing plugins that use Resources</a></h1>There are generally two kinds of plugins that provide Resources artefacts; those that expose resources such as JavaScript libraries, and those that supply custom mappers e.g. to minify resources.<p class="paragraph"/><h2>Plugin dependencies</h2><p class="paragraph"/>If your plugin exposes resources, it does not need to depend on the "resources" plugin. In fact if it is intended to interoperate with applications that do <strong class="bold">not</strong> use the Resources framework, you should not depend on the "resources" plugin. Defining XXXXResources.groovy files does not require dependency on the plugin at all.<p class="paragraph"/>If you are exposing a mapper, you will need to have a dependency on the "resources" plugin so that you can reference the MapperPhase enum.<p class="paragraph"/><h2>Versioning</h2><p class="paragraph"/>When exposing resources, it is becoming a convention to ensure that your plugin has a version number that matches the version of the libraries you are exposing - with point releases or other suffixes to denote interim plugin releases where the library is the same but the plugin has changed.<p class="paragraph"/>This is important because it allows other applications that use the library you expose to specify which version of it they require, without having to mentally map the library version to yet another plugin version.<p class="paragraph"/><h2>Avoiding bloat</h2><p class="paragraph"/>It's important to remember that the dependencies introduced by a mapper plugin end up in the user's WAR deployment. Therefore mapper plugins should have minimal dependencies, and where possible focus on a specific niche of mapping - for example avoid creating something like a monolithic "minified-resources" plugin that bundles every known minifier library together.<p class="paragraph"/><h2>Naming conventions for mapper plugins</h2><p class="paragraph"/>It is recommended that developers establish sound naming conventions in the community such that it is easy for users to tell what a mapper plugin will do for them, in a way consistent with other mapper plugins of similar type.<p class="paragraph"/>For example there may be YUI and a Google CSS minifier plugins. These should be clearly named e.g:<p class="paragraph"/>yui-css-minified-resources
google-css-minified-resources<p class="paragraph"/>In addition the mappers must be clearly named, i.e. YuiCssMinifyMapper and GoogleCssMinifyMapper. Such that the user can exclude them selectively with code such as <strong class="bold">exclude:'yuicssminify'</strong>.<p class="paragraph"/><h1><a name="8. Debugging">8. Debugging</a></h1>Due to the processing of resources, it can be tricky to diagnose problems when something is not working - your styling may not be coming through correctly, or you are getting weird JS errors.<p class="paragraph"/>Usually these are due to incorrect dependencies with your modules, but you may also have actual bugs in your JS or CSS.<p class="paragraph"/>When you're using mappers that completely rename or aggregate files, it can be hard to tell where the problem lies.<p class="paragraph"/>There are a number of features in Resources that make it easier to debug such issues.<p class="paragraph"/>First: Get familiar with your browser's resource inspector. All modern browsers have a developer mode which lets you inspect the resources loaded by a page - including the request and response headers and the content itself. This is indispensable. For Safari you need to explicitly turn this on. For Firefox you may need to install firebug.<p class="paragraph"/><h2>The custom response header</h2><p class="paragraph"/>Every resource served by the plugin in development mode adds the <strong class="bold">X-Grails-Resources-Original-Src</strong> header to all resources served.<p class="paragraph"/>The value shows you the original filename of the resource. In the case of bundled resources, the first part is the bundle name, and then follow all the names of the resources appended to the file, in the order they appear.<p class="paragraph"/><h2>The quick debug option - turn off processing for the current request</h2><p class="paragraph"/>Any URL in your application can have the query parameter <strong class="bold">_debugResources=y</strong> added to it, and the request will perform no processing. So for example if you are browsing <strong class="bold">http://localhost:8080/myapp/admin</strong> and need to bypass resources, just change the URL in your browser to
<strong class="bold">http://localhost:8080/myapp/admin?_debugResources=y</strong><p class="paragraph"/>Dependency management will still be in effect (otherwise your app would break) but the resources will not be bundled or have other mappers applied. Resources will be served with a timestamp - this allows you to set breakpoints on resources and yet also force a refresh in your browser if you find that your browser still caches resources even after you have edited them and no caching headers are set. If this occurs, you can force a timestamp refresh by adding <strong class="bold">_refreshResources=y</strong> to the query params.<p class="paragraph"/><h2>The nuclear debug option - turn on resource debugging all the time </h2><p class="paragraph"/>You can turn off resource processing completely with the trivial Config variable, so that it is as if every request you make has _debugResources=y appended to it:<p class="paragraph"/><div class="code"><pre>grails.resources.debug = <span class="java&#45;keyword">true</span></pre></div><p class="paragraph"/>You can specify this value per-environment in your Config.<p class="paragraph"/><h2>Inspecting your dependency data</h2><p class="paragraph"/>A utility function in ResourceService can be used to output the current resource metadata that the plugin has - all the modules and resources and their dependencies.<p class="paragraph"/>Simple add resourceService.dumpResources() somewhere in your application and it will come out to console.<p class="paragraph"/><h2>Turning on debug logging</h2><p class="paragraph"/>There are copious amounts of debug logging output by the plugin that should make it relatively easy to track down problems. This information includes the order of mapper execution that will be used, the dependency order of your resource module definitions, and all the steps of processing each resource.<p class="paragraph"/>To enable debug logging add this to your Config logging section:<p class="paragraph"/><div class="code"><pre>debug <span class="java&#45;quote">"org.grails.plugin.resource"</span></pre></div><h1><a name="9. Configuration">9. Configuration</a></h1>There are various configuration options to control processing of your resources.<p class="paragraph"/>All of these config variables can of course be set per-environment.<p class="paragraph"/><h2>Change the /static/ URI prefix: grails.resources.uri.prefix</h2><p class="paragraph"/>By default the plugin serves the modified static resources from URIs beginning with &#60;appcontext&#62;/static/.<p class="paragraph"/>You can change this by assigning a value to <strong class="bold">grails.resources.uri.prefix</strong><p class="paragraph"/><h2>Debug mode: grails.resources.debug</h2><p class="paragraph"/>Setting <strong class="bold">grails.resources.debug=true</strong> will force debug mode all the time, as if you added _debugResources=y to every request.<p class="paragraph"/><h2>Dependency-only mode: grails.resources.processing.enabled</h2><p class="paragraph"/>You can turn off resource processing completely with the trivial Config variable:<p class="paragraph"/><div class="code"><pre>grails.resource.processing.enabled = <span class="java&#45;keyword">false</span></pre></div><p class="paragraph"/>Like the _debugResources option, this will perform no processing at all. It will also not require a writable file system on the server, but obviously precludes any processing of resources.<p class="paragraph"/>You do however retain the dependency management abilities.<p class="paragraph"/><h2>Controlling the scope of the adhoc filter: grails.resources.adhoc.patterns</h2><p class="paragraph"/>The ad-hoc resource filter is mapped using Servlet SDK filter mappings, which are more restricted that Ant patterns. You can specify folder (xxx/<strong class="bold">) or file type (</strong>.xxx) mappings only.<p class="paragraph"/>You may not want the adhoc filter, which is used for legacy resources (which are not linked to using resource tags) only and as such you do not want it to intercept everything in your application.<p class="paragraph"/>The default value is:<p class="paragraph"/><div class="code"><pre>grails.resources.adhoc.patterns = &#91;<span class="java&#45;quote">"/images/&#42;"</span>, <span class="java&#45;quote">"&#42;.css"</span>, <span class="java&#45;quote">"&#42;.js"</span>&#93;</pre></div><p class="paragraph"/><h2>Controlling the includes and excludes of the adhoc filter: grails.resources.adhoc.includes/excludes</h2><p class="paragraph"/>While the grails.resources.adhoc.patterns setting gives you coarse control over which legacy URIs are intercepted, you can get full Ant-style include/exclude patterns using the <strong class="bold">grails.resources.adhoc.includes</strong> and <strong class="bold">grails.resources.adhoc.excludes</strong> variables.<p class="paragraph"/>They both accept a list of Ant-style patterns.<p class="paragraph"/><h2>Including specific resource patterns per-mapper: grails.resources.&#60;mappername&#62;.includes</h2><p class="paragraph"/>You can control the list of matching resources on a per-mapper basis. Mappers provide sensible defaults but you may have new content types (for example a new CSS variant such as LESS) that were not known at the time the mapper was written.<p class="paragraph"/>So for example to add .less files to processing by the CSS rewriters (necessary for correct behaviour with bundle mapper):<p class="paragraph"/><div class="code"><pre>grails.resources.cssrewriter.includes = &#91;'&#42;&#42;/&#42;.css', '&#42;&#42;/&#42;.less'&#93;
grails.resources.csspreprocessor.includes = &#91;'&#42;&#42;/&#42;.css', '&#42;&#42;/&#42;.less'&#93;</pre></div><p class="paragraph"/>You can also use this to ensure that only resources under a specific folder are processed.<p class="paragraph"/>Note that the value you provide <strong class="bold">replaces</strong> the default list supplied by the mapper.<p class="paragraph"/><h2>Excluding specific resource patterns per-mapper:grails.resources.&#60;mappername&#62;.excludes</h2><p class="paragraph"/>There may be times when a mapper is processing too many files - those that may have already been processed or that may become damaged by the mapping (i.e. incompatibilities due to relative code loading by JS code). Simply add the resource names or patterns to that mapper's excludes:<p class="paragraph"/><div class="code"><pre>grails.resources.cssrewriter.excludes = &#91;'unsafe/&#42;&#42;'&#93;
grails.resources.csspreprocessor.excludes = &#91;'unsafe/&#42;&#42;'&#93;
grails.resources.bundle.excludes = &#91;'unsafe/&#42;&#42;/&#42;.css'&#93;</pre></div><p class="paragraph"/>Note that the value you provide <strong class="bold">replaces</strong> the default list supplied by the mapper.<p class="paragraph"/><h2>Disabling CSS rewriting: grails.resources.rewrite.css</h2><p class="paragraph"/>It is possible to turn off all CSS rewriting by setting this value to false. This is not recommended as it will usually break bundling unless all your links are relative and you don't have any mappers that move your resources relative to your CSS.

        </div>
        <div id="footer">
             
        </div>
    </body>
</html>
